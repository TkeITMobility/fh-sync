<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pending-processor.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pending-processor.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var syncUtil = require('./util');
var debug = syncUtil.debug;
var debugError = syncUtil.debugError;
var metrics = require('./sync-metrics');
var util = require('util');

var syncStorage, dataHandlers, hashProvider, metricsClient;

//TODO: move this to the storage.js file
var SYNC_UPDATE_TYPES = {
  APPLIED: 'applied',
  FAILED: 'failed',
  COLLISION: 'collisions'
};

function saveUpdate(datasetId, pendingChange, type, msg, callback) {
  var syncUpdateFields = {
    type: type,
    cuid: pendingChange.cuid,
    action: pendingChange.action,
    hash: pendingChange.hash,
    uid: pendingChange.uid,
    msg: msg,
    timestamp: Date.now()
  };
  if (pendingChange.oldUid) {
    syncUpdateFields.oldUid = pendingChange.oldUid;
  }
  syncStorage.saveUpdate(datasetId, syncUpdateFields, callback);
}

function handleCollision(datasetId, metaData, pendingChange, dataHash, callback) {
  var collisionFields = {
    uid: pendingChange.uid,
    hash: dataHash,
    pre: pendingChange.pre,
    post: pendingChange.post,
    timestamp: pendingChange.timestamp
  };
  var newCollisionCount = pendingChange.datasetClient.collisionCount + 1;
  syncStorage.updateDatasetClient(pendingChange.datasetClient.id, {collisionCount: newCollisionCount}, function(err) {
    if (err) {
      debugError('[%s] Updating dataset client collision count (%s) failed : err = %s', datasetId, pendingChange.datasetClient.id, err);
    }
  });
  dataHandlers.handleCollision(datasetId, collisionFields.hash, collisionFields.timestamp, collisionFields.uid, collisionFields.pre, collisionFields.post, metaData, callback);
}

/**
 * Create the given pending change in the backend.
 * It will always create the record in the backend.
 * @param {String} datasetId the dataset id
 * @param {Object} pendingChange the pending change. It should have the following fields
 * @param {String} pendingChange.datasetId the dataset id of the pending change
 * @param {Object} pendingChange.meta_data the meta_data of the dataset
 * @param {String} pendingChange.action the action of the pending change, should be "create"
 * @param {String} pendingChange.uid the unique id of the data record. This is a temp uid generated by the client and should be replaced by the real uid once the record is created.
 * @param {String} pendingChange.cuid the unique client id of the client device
 * @param {String} pendingChange.hash a unique id of the pending change, normally it is a hash value generated from the content of the pendingChange object
 * @param {Object} pendingChange.post the record after change
 * @param {Function} callback
 */
function doCreate(datasetId, pendingChange, callback) {
  var record = pendingChange.post;
  var metaData = pendingChange.meta_data;
  debug('[%s] CREATE Start data = %j', datasetId, record);
  dataHandlers.doCreate(datasetId, record, metaData, function(err, data) {
    if (err) {
      debugError('[%s] CREATE Failed - : err = %s', datasetId, err);
    } else {
      debug('[%s] CREATE Success - uid = %s', datasetId, data.uid);
      pendingChange.oldUid = pendingChange.uid;
      pendingChange.uid = data.uid;
    }
    return saveUpdate(datasetId, pendingChange, err ? SYNC_UPDATE_TYPES.FAILED : SYNC_UPDATE_TYPES.APPLIED, err ? util.inspect(err) : null, callback);
  });
}

/**
 * Update the given pending change in the backend.
 * It will only update the record if the hash value of the `pre` record matches the hash value of the record from backend.
 * Otherwise the change is either already applied, or a collision will be generated.
 * @param {String} datasetId the dataset id
 * @param {Object} pendingChange the pending change. It should have the following fields
 * @param {String} pendingChange.datasetId the dataset id of the pending change
 * @param {Object} pendingChange.meta_data the meta_data of the dataset
 * @param {String} pendingChange.action the action of the pending change, should be "update"
 * @param {String} pendingChange.uid the unique id of the data record
 * @param {String} pendingChange.cuid the unique client id of the client device
 * @param {String} pendingChange.hash a unique id of the pending change, normally it is a hash value generated from the content of the pendingChange object
 * @param {Object} pendingChange.pre the record before change.
 * @param {Object} pendingChange.post the record after change
 * @param {Function} callback
 */
function doUpdate(datasetId, pendingChange, callback) {
  debug('[%s] UPDATE Start', datasetId);
  var metaData = pendingChange.meta_data;
  var uid = pendingChange.uid;
  dataHandlers.doRead(datasetId, uid, metaData, function(err, data) {
    if (err) {
      debugError('[%s] READ for UPDATE Failed - uid = %s : err = %s', datasetId, uid, err);
      return saveUpdate(datasetId, pendingChange, SYNC_UPDATE_TYPES.FAILED, util.inspect(err), callback);
    }
    debug('[%s] READ for UPDATE Success', datasetId);
    debug('[%s] READ for UPDATE Data : \n%j', datasetId, data);

    var preHash = hashProvider.recordHash(datasetId, pendingChange.pre);
    var dataHash = hashProvider.recordHash(datasetId, data);

    debug('[%s] UPDATE Hash Check %s (client :: dataStore) = %s :: ' + dataHash, datasetId, uid, preHash);

    if (preHash === dataHash) {
      dataHandlers.doUpdate(datasetId, uid, pendingChange.post, metaData, function(err) {
        if (err) {
          debugError('[%s] UPDATE Failed - uid = %s : err = %s', datasetId, uid, err);
        } else {
          debug('[%s] UPDATE Success - uid = %s : hash = %s', datasetId, uid, dataHash);
        }
        return saveUpdate(datasetId, pendingChange, err ? SYNC_UPDATE_TYPES.FAILED : SYNC_UPDATE_TYPES.APPLIED, err ? util.inspect(err) : null, callback);
      });
    } else {
      var postHash = hashProvider.recordHash(datasetId, pendingChange.post);
      if (postHash === dataHash) {
        // Update has already been applied
        debug('[%s] UPDATE Already Applied - uid = %s : hash = %s', datasetId, uid, dataHash);
        return saveUpdate(datasetId, pendingChange, SYNC_UPDATE_TYPES.APPLIED, null, callback);
      }
      else {
        debug('[%s] UPDATE COLLISION \n Pre record from client:\n%j\nCurrent record from data store:\n%j', datasetId, syncUtil.sortObject(pendingChange.pre), syncUtil.sortObject(data));
        handleCollision(datasetId, metaData, pendingChange, dataHash, function(err) {
          if (err) {
            debugError('[%s] Failed to save collision uid = %s : err = %s', datasetId, uid, err);
          }
        });
        return saveUpdate(datasetId, pendingChange, SYNC_UPDATE_TYPES.COLLISION, null, callback);
      }
    }
  });
}

/**
 * Delete the given pending change from the backend.
 * It will only delete the record if the hash value of the `pre` record matches the hash value of the record from backend.
 * Otherwise the change is either already applied, or a collision will be generated.
 * @param {String} datasetId the dataset id
 * @param {Object} pendingChange the pending change. It should have the following fields
 * @param {String} pendingChange.datasetId the dataset id of the pending change
 * @param {Object} pendingChange.meta_data the meta_data of the dataset
 * @param {String} pendingChange.action the action of the pending change, should be "delete"
 * @param {String} pendingChange.uid the unique id of the data record
 * @param {String} pendingChange.cuid the unique client id of the client device
 * @param {String} pendingChange.hash a unique id of the pending change, normally it is a hash value generated from the content of the pendingChange object
 * @param {Object} pendingChange.pre the record before change.
 * @param {Function} callback
 */
function doDelete(datasetId, pendingChange, callback) {
  debug('[%s] DELETE Start', datasetId);
  var metaData = pendingChange.meta_data;
  var uid = pendingChange.uid;
  dataHandlers.doRead(datasetId, uid, metaData, function(err, data) {
    if (err) {
      debugError('READ for DELETE Failed - uid = %s : err = %s', datasetId, uid, err);
      return saveUpdate(datasetId, pendingChange, SYNC_UPDATE_TYPES.FAILED, util.inspect(err), callback);
    }
    debug('[%s] READ for DELETE Success', datasetId);
    debug('[%s] READ for DELETE Data : \n%j', datasetId, data);

    var preHash = hashProvider.recordHash(datasetId, pendingChange.pre);
    var dataHash = hashProvider.recordHash(datasetId, data);

    debug('[%s] DELETE Hash Check %s (client :: dataStore) = %s :: %s', datasetId, uid, preHash.dataHash);

    if (!dataHash) {
      //record has already been deleted
      debug('[%s] DELETE Already performed - uid=%s', datasetId, uid);
      return saveUpdate(datasetId, pendingChange, SYNC_UPDATE_TYPES.APPLIED, null, callback);
    }
    else {
      if (preHash === dataHash) {
        dataHandlers.doDelete(datasetId, uid, metaData, function(err) {
          if (err) {
            debugError('[%s] DELETE Failed - uid=%s : err = %s', datasetId, err);
          } else {
            debug('[%s] DELETE Success - uid=%s : hash = %s', datasetId, dataHash);
          }
          return saveUpdate(datasetId, pendingChange, err ? SYNC_UPDATE_TYPES.FAILED : SYNC_UPDATE_TYPES.APPLIED, err ? util.inspect(err) : null, callback);
        });
      } else {
        debug('[%s] DELETE COLLISION \n Pre record from client:\n%j\nCurrent record from data store:\n%j', datasetId, syncUtil.sortObject(pendingChange.pre), syncUtil.sortObject(data));
        handleCollision(datasetId, metaData, pendingChange, dataHash, function(err) {
          if (err) {
            debugError('[%s] Failed to save collision uid = %s : err = %s', datasetId, err);
          }
        });
        return saveUpdate(datasetId, pendingChange, SYNC_UPDATE_TYPES.COLLISION, null, callback);
      }
    }
  });
}

/**
 * apply the given pending change to the backend using the dataHandlers
 * @param {Object} pendingChange the pending change object
 * @param {String} pendingChange.datasetId the dataset id of the pending change
 * @param {Object} pendingChange.meta_data the meta_data of the dataset
 * @param {String} pendingChange.action the action of the pending change, should be one of "create", "update" or "delete"
 * @param {String} pendingChange.uid the unique id of the data record
 * @param {String} pendingChange.cuid the unique client id of the client device
 * @param {String} pendingChange.hash a unique id of the pending change, normally it is a hash value generated from the content of the pendingChange object
 * @param {Object} pendingChange.pre the record before change. Optional.
 * @param {Object} pendingChange.post the record after change. Optional.
 * @param {Number} tries a counter to record how many times the given pending change has been executed
 * @param {Function} callback the callback function
 * @returns
 */
function applyPendingChange(pendingChange, tries, callback) {
  var datasetId = pendingChange.datasetId;
  if (!datasetId || !pendingChange.action || !pendingChange.uid || !pendingChange.cuid || !pendingChange.hash) {
    debugError("[%s] invalid pendingChange request dropped :: item = %j", datasetId, pendingChange);
    return callback();
  }
  debug('[%s] processPending :: item = %j', datasetId, pendingChange);
  if (tries > 1) {
    //the pendingChange has been processed before but it didn't complete, most likely the process crashedd. Mark it as failed
    debugError('[%s] processPending failed :: tries = %d  :: item = %j', datasetId, tries, pendingChange);
    return saveUpdate(datasetId, pendingChange, SYNC_UPDATE_TYPES.FAILED, "crashed", callback);
  }
  var action = pendingChange.action.toLowerCase();

  var timer = metrics.startTimer();

  function onComplete(err) {
    metricsClient.gauge(metrics.KEYS.PENDING_CHANGE_PROCESS_TIME, {success: !err, action: action}, timer.stop());
    return callback(err);
  }

  switch (action) {
    case "create":
      doCreate(datasetId, pendingChange, onComplete);
      break;
    case "update":
      doUpdate(datasetId, pendingChange, onComplete);
      break;
    case "delete":
      doDelete(datasetId, pendingChange, onComplete);
      break;
    default:
      debugError("[%s] invalid pendingChange request dropped :: item = %j", datasetId, pendingChange);
      return onComplete();
  }
}

module.exports = function(syncStorageImpl, dataHandlersImpl, hashProviderImpl, metricsClientImpl) {
  syncStorage = syncStorageImpl;
  dataHandlers = dataHandlersImpl;
  hashProvider = hashProviderImpl;
  metricsClient = metricsClientImpl;
  return function(pendingChangeRequest, callback) {
    var pendingChange = pendingChangeRequest.payload;
    var tries = pendingChangeRequest.tries;
    return applyPendingChange(pendingChange, tries, callback);
  }
};

module.exports.SYNC_UPDATE_TYPES = SYNC_UPDATE_TYPES;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addToQueue">addToQueue</a></li><li><a href="global.html#aggregateData">aggregateData</a></li><li><a href="global.html#applyPendingChange">applyPendingChange</a></li><li><a href="global.html#collisionHandler">collisionHandler</a></li><li><a href="global.html#computeDelta">computeDelta</a></li><li><a href="global.html#connect">connect</a></li><li><a href="global.html#convertToObject">convertToObject</a></li><li><a href="global.html#createHandler">createHandler</a></li><li><a href="global.html#DatasetClient">DatasetClient</a></li><li><a href="global.html#DatasetClientsCleaner">DatasetClientsCleaner</a></li><li><a href="global.html#debugError">debugError</a></li><li><a href="global.html#DEFAULT_SYNC_CONF">DEFAULT_SYNC_CONF</a></li><li><a href="global.html#defaultHashFn">defaultHashFn</a></li><li><a href="global.html#del">del</a></li><li><a href="global.html#deleteHandler">deleteHandler</a></li><li><a href="global.html#doCreate">doCreate</a></li><li><a href="global.html#doDelete">doDelete</a></li><li><a href="global.html#doList">doList</a></li><li><a href="global.html#doRead">doRead</a></li><li><a href="global.html#doUpdate">doUpdate</a></li><li><a href="global.html#ensureQueueCreated">ensureQueueCreated</a></li><li><a href="global.html#formatUpdates">formatUpdates</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getDefaultHashFn">getDefaultHashFn</a></li><li><a href="global.html#getGlobalHashFn">getGlobalHashFn</a></li><li><a href="global.html#getRecordHashFn">getRecordHashFn</a></li><li><a href="global.html#globalCollisionHandler">globalCollisionHandler</a></li><li><a href="global.html#globalCreateHandler">globalCreateHandler</a></li><li><a href="global.html#globalDeleteHandler">globalDeleteHandler</a></li><li><a href="global.html#globalHash">globalHash</a></li><li><a href="global.html#globalListCollisionsHandler">globalListCollisionsHandler</a></li><li><a href="global.html#globalListHandler">globalListHandler</a></li><li><a href="global.html#globalReadHandler">globalReadHandler</a></li><li><a href="global.html#globalRemoveCollisionHandler">globalRemoveCollisionHandler</a></li><li><a href="global.html#globalUpdateHandler">globalUpdateHandler</a></li><li><a href="global.html#handleCollision">handleCollision</a></li><li><a href="global.html#handleRedisError">handleRedisError</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#invoke">invoke</a></li><li><a href="global.html#invokeFunctions">invokeFunctions</a></li><li><a href="global.html#listAppliedChangeSinceLastSync">listAppliedChangeSinceLastSync</a></li><li><a href="global.html#listChangesNotInLocalDataset">listChangesNotInLocalDataset</a></li><li><a href="global.html#listCollisions">listCollisions</a></li><li><a href="global.html#listCollisionsHandler">listCollisionsHandler</a></li><li><a href="global.html#listHandler">listHandler</a></li><li><a href="global.html#listLocalDatasetClientData">listLocalDatasetClientData</a></li><li><a href="global.html#listPendingChangesForClient">listPendingChangesForClient</a></li><li><a href="global.html#MongodbQueue">MongodbQueue</a></li><li><a href="global.html#overrides">overrides</a></li><li><a href="global.html#processAcknowledgement">processAcknowledgement</a></li><li><a href="global.html#QueueWorker">QueueWorker</a></li><li><a href="global.html#readHandler">readHandler</a></li><li><a href="global.html#recordHash">recordHash</a></li><li><a href="global.html#removeAppliedUpdates">removeAppliedUpdates</a></li><li><a href="global.html#removeCollision">removeCollision</a></li><li><a href="global.html#removeCollisionHandler">removeCollisionHandler</a></li><li><a href="global.html#removePendingChanges">removePendingChanges</a></li><li><a href="global.html#removeUpdatesInRequest">removeUpdatesInRequest</a></li><li><a href="global.html#requestInterceptor">requestInterceptor</a></li><li><a href="global.html#responseInterceptor">responseInterceptor</a></li><li><a href="global.html#restore">restore</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setDefaultRequestInterceptor">setDefaultRequestInterceptor</a></li><li><a href="global.html#setDefaultResponseInterceptor">setDefaultResponseInterceptor</a></li><li><a href="global.html#setGlobalHashFn">setGlobalHashFn</a></li><li><a href="global.html#setRecordHashFn">setRecordHashFn</a></li><li><a href="global.html#setRequestInterceptor">setRequestInterceptor</a></li><li><a href="global.html#setResponseInterceptor">setResponseInterceptor</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#stopAll">stopAll</a></li><li><a href="global.html#sync">sync</a></li><li><a href="global.html#syncRecords">syncRecords</a></li><li><a href="global.html#SyncScheduler">SyncScheduler</a></li><li><a href="global.html#syncWithBackend">syncWithBackend</a></li><li><a href="global.html#updateHandler">updateHandler</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri May 19 2017 18:47:37 GMT+0100 (IST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
