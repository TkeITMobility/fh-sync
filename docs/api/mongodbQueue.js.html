<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: mongodbQueue.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: mongodbQueue.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var mongodbQ = require('mongodb-queue');
var metrics = require('./sync-metrics');
var _ = require('underscore');
var async = require('async');
var syncUtil = require('./util');
var debug = syncUtil.debug;
var debugError = syncUtil.debugError;

/**
 * Make sure the real queue is created. Otherwise throws an error.
 */
function ensureQueueCreated(target) {
  if (!target.queue) {
    throw new Error('queue ' + target.queueName + ' is not created yet. Please call queue.create first');
  }
}

/**
 * construct a new queue that is backed by mongodb.
 * @param {String} name the name of the queue.
 * @param {Object} metrics an instance of fh-component-metrics client
 * @param {Object} lock an instance of the lock service
 * @param {Object} opts configuration options for the queue
 * @param {Object} opts.mongodb an instance of the mongodb connection. This is required.
 * @param {Number} opts.visibility see https://github.com/chilts/mongodb-queue#visibility---message-visibility-window
 * @param {Object} opts.queueMessagesTTL The TTL (time to live) value for the messages on the queue. Default to 24 hours.
 */
function MongodbQueue(name, metrics, lock, opts) {
  if (!name) {
    throw new Error('name is required to create a mongodb queue');
  }
  if (!opts || !opts.mongodb) {
    throw new Error('mongodb is not specified to create mongodb queue');
  }
  this.queueName = name;
  this.metrics = metrics;
  this.lock = lock;
  this.lockName = opts.lockName || ('lock:sync:' + this.queueName);
  this.lockTimeout = opts.lockTimeout || 10000;
  this.mongodb = opts.mongodb;
  this.queueOptions = {visibility: opts.visibility || 30};
  this.queueTTL = opts.queueMessagesTTL || 24*60*60;
  this.queue;
}

/**
 * @function MongodbQueue~createCallback
 * @param {Error} err An error occured when trying to create queue
 * @param {Object} queue The queue instance that is created
 */

/**
 * create the queue.
 * @param {MongodbQueue~createCallback} cb the callback function
 */
MongodbQueue.prototype.create = function(cb) {
  var self = this;
  if (self.queue) {
    return cb(null, self.queue);
  } else {
    self.queue = mongodbQ(self.mongodb, self.queueName, self.queueOptions);
    var collection = self.mongodb.collection(self.queueName);
    var indexName = 'deleted_1';
    self.lock.acquire(self.lockName, self.lockTimeout, function(err, lockCode){
      if (err) {
        debugError('[%s] failed to acquire lock %s due to error : %s', self.queueName, self.lockName, err);
        return cb(err);
      }
      if (!lockCode) {
        debug('[%s] can not acquire lock. Skip creating queuing index.', self.queueName, self.lockName);
        return cb(null, self.queue);
      } else {
        debug('[%s] lock %s acquired. Continue.', self.queueName, self.lockName);
        async.waterfall([
          function createIndexes(callback) {
            debug('[%s] creating queue indexes', self.queueName);
            self.queue.createIndexes(callback);
          },
          function addExtraIdIndex(createdIndex, callback) {
            debug('[%s] adding extra _id index for queue', self.queueName);
            collection.createIndex({ deleted : 1, visible : 1, _id : 1}, callback);
          },
          function addExtraAckIndex(createdIndex, callback) {
            debug('[%s] adding extra ack index for queue', self.queueName);
            collection.createIndex({ ack: 1, visible : 1, deleted : 1}, callback);
          },
          function listIndexes(createdIndex, callback) {
            debug('[%s] list existing indexes', self.queueName);
            collection.indexInformation({full: true}, callback);
          },
          function checkIndexTTL(indexInfo, callback) {
            debug('[%s] found queue indexInfo : %j', self.queueName, indexInfo);
            var existingIndex = _.findWhere(indexInfo, {name: indexName});
            var needDrop = false;
            var needCreate = false;

            if (!existingIndex) {
              needCreate = true;
            } else if (existingIndex.expireAfterSeconds !== self.queueTTL) {
              needDrop = true;
              needCreate = true;
            }
            return callback(null, needDrop, needCreate);
          },
          function dropTTLIndex(needDrop, needCreate, callback) {
            if (needDrop) {
              debug('[%s] dropping ttl index: %s', self.queueName, indexName);
              collection.dropIndex(indexName, function(err){
                return callback(err, needCreate);
              });
            } else {
              debug('[%s] skip dropping ttl index', self.queueName);
              return callback(null, needCreate);
            }
          },
          function createTTLIndex(needCreate, callback) {
            if (needCreate) {
              debug('[%s] creating ttl index: %s', self.queueName, indexName);
              collection.createIndex({'deleted': 1}, {'expireAfterSeconds': self.queueTTL, 'backgroud': true}, callback);
            } else {
              debug('[%s] skip creating ttl index', self.queueName);
              return callback();
            }
          }
        ], function(err){
          if (err) {
            debugError('[%s] failed to create queue index due to error: %s', self.queueName, err);
            return cb(err);
          }
          self.lock.release(self.lockName, lockCode, function(releaseErr){
            if (releaseErr) {
              debugError('[%s] failed to release lock due to error: %s', self.queueName, releaseErr);
            }
          });
          return cb(null, self.queue);
        });
      }
    });
  }
};

/**
 * See https://github.com/chilts/mongodb-queue for details about those methods.
 * We may not need all those methods, we can review them and remove the ones that we don't need.
 */
['add', 'get', 'ack', 'ping', 'total', 'size', 'inFlight', 'done', 'clean'].forEach(function(methodName) {
  MongodbQueue.prototype[methodName] = function() {
    var self = this;
    ensureQueueCreated(self);
    var args = [].slice.call(arguments);
    var callback = args.pop();
    if (typeof callback !== 'function') {
      throw new Error("no callback function found for queue." + methodName);
    }
    var timer = metrics.startTimer();
    args.push(function() {
      var timing = timer.stop();
      self.metrics.gauge(metrics.KEYS.QUEUE_OPERATION_TIME, {method: methodName, name: self.queueName}, timing);
      return callback.apply(null, arguments);
    });
    self.queue[methodName].apply(self.queue, args);
  };
});

MongodbQueue.prototype.getName = function() {
  return this.queueName;
};

MongodbQueue.prototype.addMany = function(messages, cb) {
  if (messages.length === 0) {
    return cb();
  }
  var self = this;
  return self.add(messages, cb); //it supports an array of messages since v2.2.0
};

//TODO: add this to the mongodb-queue module
MongodbQueue.prototype.search = function(searchFields, cb) {
  var self = this;
  var collection = self.mongodb.collection(self.queueName);
  var query = {
    deleted: {$exists: false},
    payload: searchFields
  };
  var timer = metrics.startTimer();
  collection.find(query).toArray(function(err, docs){
    self.metrics.gauge(metrics.KEYS.QUEUE_OPERATION_TIME, {method: 'search', name: self.queueName}, timer.stop());
    if (err) {
      return cb(err);
    }
    return cb(null, _.pluck(docs, 'payload'));
  });
};

module.exports = MongodbQueue;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addToQueue">addToQueue</a></li><li><a href="global.html#aggregateData">aggregateData</a></li><li><a href="global.html#applyPendingChange">applyPendingChange</a></li><li><a href="global.html#collisionHandler">collisionHandler</a></li><li><a href="global.html#computeDelta">computeDelta</a></li><li><a href="global.html#connect">connect</a></li><li><a href="global.html#convertToObject">convertToObject</a></li><li><a href="global.html#createHandler">createHandler</a></li><li><a href="global.html#DatasetClient">DatasetClient</a></li><li><a href="global.html#DatasetClientsCleaner">DatasetClientsCleaner</a></li><li><a href="global.html#debugError">debugError</a></li><li><a href="global.html#DEFAULT_SYNC_CONF">DEFAULT_SYNC_CONF</a></li><li><a href="global.html#defaultHashFn">defaultHashFn</a></li><li><a href="global.html#del">del</a></li><li><a href="global.html#deleteHandler">deleteHandler</a></li><li><a href="global.html#doCreate">doCreate</a></li><li><a href="global.html#doDelete">doDelete</a></li><li><a href="global.html#doList">doList</a></li><li><a href="global.html#doRead">doRead</a></li><li><a href="global.html#doUpdate">doUpdate</a></li><li><a href="global.html#ensureQueueCreated">ensureQueueCreated</a></li><li><a href="global.html#formatUpdates">formatUpdates</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getDefaultHashFn">getDefaultHashFn</a></li><li><a href="global.html#getGlobalHashFn">getGlobalHashFn</a></li><li><a href="global.html#getRecordHashFn">getRecordHashFn</a></li><li><a href="global.html#globalCollisionHandler">globalCollisionHandler</a></li><li><a href="global.html#globalCreateHandler">globalCreateHandler</a></li><li><a href="global.html#globalDeleteHandler">globalDeleteHandler</a></li><li><a href="global.html#globalHash">globalHash</a></li><li><a href="global.html#globalListCollisionsHandler">globalListCollisionsHandler</a></li><li><a href="global.html#globalListHandler">globalListHandler</a></li><li><a href="global.html#globalReadHandler">globalReadHandler</a></li><li><a href="global.html#globalRemoveCollisionHandler">globalRemoveCollisionHandler</a></li><li><a href="global.html#globalUpdateHandler">globalUpdateHandler</a></li><li><a href="global.html#handleCollision">handleCollision</a></li><li><a href="global.html#handleRedisError">handleRedisError</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#invoke">invoke</a></li><li><a href="global.html#invokeFunctions">invokeFunctions</a></li><li><a href="global.html#listAppliedChangeSinceLastSync">listAppliedChangeSinceLastSync</a></li><li><a href="global.html#listChangesNotInLocalDataset">listChangesNotInLocalDataset</a></li><li><a href="global.html#listCollisions">listCollisions</a></li><li><a href="global.html#listCollisionsHandler">listCollisionsHandler</a></li><li><a href="global.html#listHandler">listHandler</a></li><li><a href="global.html#listLocalDatasetClientData">listLocalDatasetClientData</a></li><li><a href="global.html#listPendingChangesForClient">listPendingChangesForClient</a></li><li><a href="global.html#MongodbQueue">MongodbQueue</a></li><li><a href="global.html#overrides">overrides</a></li><li><a href="global.html#processAcknowledgement">processAcknowledgement</a></li><li><a href="global.html#QueueWorker">QueueWorker</a></li><li><a href="global.html#readHandler">readHandler</a></li><li><a href="global.html#recordHash">recordHash</a></li><li><a href="global.html#removeAppliedUpdates">removeAppliedUpdates</a></li><li><a href="global.html#removeCollision">removeCollision</a></li><li><a href="global.html#removeCollisionHandler">removeCollisionHandler</a></li><li><a href="global.html#removePendingChanges">removePendingChanges</a></li><li><a href="global.html#removeUpdatesInRequest">removeUpdatesInRequest</a></li><li><a href="global.html#requestInterceptor">requestInterceptor</a></li><li><a href="global.html#responseInterceptor">responseInterceptor</a></li><li><a href="global.html#restore">restore</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setDefaultRequestInterceptor">setDefaultRequestInterceptor</a></li><li><a href="global.html#setDefaultResponseInterceptor">setDefaultResponseInterceptor</a></li><li><a href="global.html#setGlobalHashFn">setGlobalHashFn</a></li><li><a href="global.html#setRecordHashFn">setRecordHashFn</a></li><li><a href="global.html#setRequestInterceptor">setRequestInterceptor</a></li><li><a href="global.html#setResponseInterceptor">setResponseInterceptor</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#stopAll">stopAll</a></li><li><a href="global.html#sync">sync</a></li><li><a href="global.html#syncRecords">syncRecords</a></li><li><a href="global.html#SyncScheduler">SyncScheduler</a></li><li><a href="global.html#syncWithBackend">syncWithBackend</a></li><li><a href="global.html#updateHandler">updateHandler</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri May 19 2017 18:47:37 GMT+0100 (IST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
